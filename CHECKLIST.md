By [KIVagant](https://habr.com/ru/users/KIVagant/)

[Чек-лист: что нужно было делать до того, как запускать микросервисы в prod](
https://habr.com/ru/post/438064/)

### Contents:
- [Короткое описание в Readme](#короткое-описание-в-readme)
- [Runbooks созданы](#runbooks-созданы)

#You need to be this tall to use [micro] services:

## Короткое описание в Readme
```
Содержит короткое описание себя в самом начале Readme.md в своём репозитории.
```

## Интеграция с системой мониторинга
```
Шлёт метрики в DataDog, NewRelic, Prometheus и так далее.
```
_Анализ потребления ресурсов, утечек памяти, stacktraces, 
взаимозависимости сервисов, частота ошибок — без понимания всего этого 
(и не только) крайне сложно контролировать что происходит 
в большом распределённом приложении._

## Оповещения настроены
```
Для сервиса включены оповещения (alerts), которые покрывают все стандартные 
ситуации плюс известные уникальные ситуации.
```

Метрики это хорошо, но следить за ними никто не будет. 
Поэтому автоматически получаем звонки/пуши/смс если:
* Потребление CPU/памяти резко возросло.
* Трафик резко возрос/упал.
* Количество обрабатываемых транзакций в секунду резко изменилось в любую 
сторону.
* Размер артефакта после сборки резко изменился (exe, app, jar, ...).
* Процент ошибок или их частота превысила допустимый порог.
* Сервис перестал слать метрики (часто пропускаемая ситуация).
* Регулярность определённых ожидаемых событий нарушена (cron job-а не 
срабатывает, не все ивенты обрабатываются etc.)


## Runbooks созданы
```
Для сервиса создан документ, описывающий известные или ожидаемые нештатные 
ситуации.
```
* как убедиться, что ошибка внутренняя и не зависит от third-party;
* если зависит, куда, кому и что писать;
* как его безопасно перезапустить;
* как восстановить из бекапа и где лежат бекапы;
* какие специальные dashboards/queries созданы для мониторинга этого сервиса;
* есть ли у сервиса своя админ-панель и как туда попасть;
* есть ли API / CLI и как пользоваться для исправления известных проблем;
* и так далее. 

## Все логи пишутся в STDOUT/STDERR
```
Сервис не создаёт никаких файлов с логами в режиме работы в production, 
не отправляет их в какие-либо внешние сервисы, 
не содержит никаких избыточных абстракций для log rotation и т.п.
```

## Логи — это Json
```
Каждая строчка лога написана в формате Json и содержит согласованный набор полей
```

* timestamp с миллисекундами согласно RFC 3339;
* level: info, warning, error, debug
* user_id;
* app_name,
* Request-Id,
* и другие поля.

ElasticSearch

## Логи с уровнями verbosity
```
Приложение должно поддерживать переменную окружения, например LOG_LEVEL, с как 
минимум двумя режимами работы: ERRORS и DEBUG.
```

Желательно, чтобы все сервисы в одной экосистеме поддерживали одну и ту же 
переменную окружения.

## Фиксированные версии зависимостей
```
Зависимости для пакетных менеджеров указаны фиксированно, включая минорные 
версии (Например, cool_framework=2.5.3).
```

## Конфигурация через окружение
```
Все важные опции конфигурации читаются из окружения и окружение имеет 
приоритет выше чем у конфигурационных файлов (но ниже чем у аргументов 
командной строки при запуске).
```

## Readiness and Liveness probes
```
Содержит соответствующие endpoints или команды cli для проверки готовности 
обслуживать запросы при старте и работоспособности в течение жизни.
```

Если приложение обслуживает HTTP запросы, оно должно по-умолчанию иметь 
два интерфейса:

1. Для проверки, что приложение живое и не зависло, используется Liveness-проба. 
2. Для проверки, что приложение не просто запустилось, но уже готово принимать 
запросы, выполняется Readiness-проба. Если приложение установило соединение с 
базой данных, системой очередей и так далее, оно должно ответить статусом от 
200 до 400 (для Kubernetes).

## Ограничения ресурсов
```
Содержит лимиты потребления памяти, CPU, дискового пространства и любых других 
доступных ресурсов в согласованном формате.
```

Эти лимиты обязаны быть заданы в едином формате для всех сервисов, быть разными 
для разных окружений (prod, dev, test, ...) и находиться вне репозитория с 
кодом приложения.

## Сборка и доставка автоматизирована
```
CI/CD-система, используемая в вашей организации или проекте, сконфигурирована и 
может доставить приложение на нужное окружение согласно принятому рабочему 
процессу (workflow).
```

## Graceful shutdown – корректное выключение
```
Приложение умеет обрабатывать SIGTERM и другие сигналы и планомерно прерывать 
свою работу после окончания обработки текущей задачи.
```

[dumb-init](https://github.com/Yelp/dumb-init)
[https://12factor.net/disposability](https://12factor.net/disposability)
[https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
](https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
)

## Соединение с базой данных регулярно проверяется
``` 
Приложение постоянно пингует базу данных и автоматически реагирует на 
исключение "потеря соединения" при любых запросах, пытаясь восстановить его 
самостоятельно или корректно завершает свою работу
```

## Масштабируется горизонтально
``` 
При росте нагрузки достаточно запустить больше экземпляров приложения, чтобы 
обеспечить обработку всех запросов или задач.
```

## Dead letter queues и устойчивость к "плохим" сообщениям
``` 
Если сервис слушает очереди или реагирует на события, изменение формата или 
содержимого сообщений не приводит к его падению. Неудачные попытки обработать 
задачу повторяются N раз, после чего сообщение отправляется в Dead Letter Queue.
```

## Ограничение на количество обрабатываемых сообщений и задач одним процессом
``` 
Поддерживает переменную окружения, которой можно принудительно ограничить 
максимальное количество обрабатываемых задач, после которого сервис 
корректно завершит работу.
```

## Не использует third-party интеграции с фильтрацией по IP адресам
``` 
Если приложение делает запросы к стороннему сервису, который допускает 
обращения с ограниченных IP-адресов, сервис выполняет эти обращения 
опосредованно через обратный прокси.
```

[reverse proxy](https://en.wikipedia.org/wiki/Reverse_proxy)

## Очевидный HTTP User-agent
```
Сервис подменяет заголовок User-agent на кастомизированный для всех запросов к 
любым API и этот заголовок содержит достаточно информации о самом сервисе и его 
версии.
```

## Не нарушает лицензии
``` 
Не содержит зависимости, чрезмерно ограничивающие применение, не является 
копией чужого кода и так далее.
```

## Не использует неподдерживаемые зависимости
``` 
При первом запуске сервиса в него не включены зависимости, которые уже устарели.
```

